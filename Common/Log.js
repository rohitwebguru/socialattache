// ========================================================================
//        Copyright (c) 2010 Dominique Lacerte, All Rights Reserved.
// 
// Redistribution and use in source and binary forms are prohibited without 
//   prior written consent from Dominique Lacerte (internet@lacerte.org).
// ========================================================================

// ===================================================================
//
//	NOTE: The global variable Form_RootUri can be defined such as "https://socialattache.com" for non-website usage.
//
// ===================================================================

const NormalLogFileSize = 20000;		// with full logging send it when it gets to this size
const MaxLogFileSize = 100000;	// when we're only looking for errors let it get a bit bigger as we won't have previous stuff
const LogUploadChunkSize = 50000;

var AccumulatedLogging = '';
var LogHasError = false;
var MetaLogging = {};
var GroupName = 'Browser';
var ClientPrefix = '';	// only used for the content script in the browser extension
var TimeoutStarted = null;
var FullLogging = false;	// do we send the log file whenever it reaches a certain size?
var LogTimeOffset = null;
var LogAlarmListenerAdded = false;

function GetHexString(str)
{
   let out = '';
   
   for (let i = 0; i < str.length; i++)
   {
      let c = str.charAt(i);
      if ((c >= 'a' && c <= 'z') ||
         (c >= 'A' && c <= 'Z') ||
         (c >= '0' && c <= '9') ||
         '<>/\\=-_()*&%$#@!{}[]\'":;,.? '.indexOf(c) !== -1)
      {
         out += c;
      }
      else
      {
         let d = str.charCodeAt(i).toString(16);
         if (d.length < 2)
            d = '0' + d;
         out += '0x' + d;
      }
   }
   
   return out;
}

function GetVariableAsString(obj)
{
   return JSON.stringify(obj, null, 4);
}

function Log_SetFullLogging(enable)
{
   FullLogging = enable;
}

// we can provide information that is included with each log file sent to the server, and each of these
// pieces of meta information has a name so it can be individually updated (or removed if the value is null)
function Log_SetMetaLogging(name, value)
{
   if (value === null)
      delete MetaLogging[name];
   else
      MetaLogging[name] = value;
}

function Log_SetGroupName(name)
{
   GroupName = name;
}

function Log_SetPrefix(prefix)
{
   ClientPrefix = '[' + prefix + '] ';
}

function Log_DateAndTime()
{
   if (LogTimeOffset == null)
   {
      // show times in America/Vancouver, note approximation for DST - DRL FIXIT! This is a hack!
      let month = (new Date()).getMonth();
      // use DST for March to October inclusive
      LogTimeOffset = (month >= 2 && month <= 9) ? -25200 : -28800;
   }
   
   // convert GMT to America/Vancouver
   let date = new Date((new Date()).getTime() + LogTimeOffset * 1000);
   
   // convert 2022-01-15T16:17:30.814Z to 2022/01/15 16:17:30
   let str = date.toISOString();
   return str.substring(0, str.indexOf('.')).replace('T', ' ').replace(/-/g, '/');
}

function Log_Write(severity, msg)
{
   let output = Log_DateAndTime() + ' ' + severity.toUpperCase() + ': ' + msg;
   if (window.console && window.console.log)
      window.console.log(output);
   else if (window.opera && window.opera.postError)
      window.opera.postError(output);
   
   if (Browser.IsExtensionContent())
   {
      // ignore this error happening when I reload the extension
      if (msg.includes('Extension context invalidated') ||
         // ignore this error generated by some websites we scrape
         msg.includes('ResizeObserver loop limit exceeded') ||
         msg.includes('ResizeObserver loop completed'))
         return;
      
      try
      {
         // allow the background script to do the accumulating, also we have to let the
         // background script send it or it'll get blocked by the browser
         chrome.runtime.sendMessage({type: 'logging', severity: severity, msg: ClientPrefix + msg}, function()
         {
            var lastError = chrome.runtime.lastError;
            if (lastError != null)
            {
               // we can't log it because this would cause another failure, so just put it on the console
               console.log('Error sending message "logging": ' + lastError.message);
            }
         });
      }
      catch (e)
      {
         console.log('Ignoring error during logging...');
         console.log(e);
      }
      
      return;
   }
   
   AccumulatedLogging += Log_DateAndTime() + ' ' + severity.toUpperCase() + ': ' + msg + "\n";
   
   // let's not hold too much data, truncate every 4000 bytes over our limit unless we have a timer set
   //  in which case we keep accumulating so we don't lose any logging that could be important
   if (!TimeoutStarted && AccumulatedLogging.length > MaxLogFileSize + 4000)
      AccumulatedLogging = AccumulatedLogging.substr(MaxLogFileSize - AccumulatedLogging.length);
   
   if (severity == 'error')
      LogHasError = true;
   
   // send the log file if we have an error or if full logging is enabled and it gets to a significant size
   if (!LogHasError && (!FullLogging || AccumulatedLogging.length < NormalLogFileSize))
      return;
   
   // don't try to send while we are offline as it'll fail
   if (!navigator.onLine)
      return;
   
   // if there is an upload in progress don't try to start another
   if (logUploadClientFileID)
      return;
   
   // we will send the log after a slight delay in case there is additional logging
   // coming right after the initial error (such as information about the state, etc.)
   if (TimeoutStarted)
      return;
   
   if (Browser.IsExtensionBackground())
   {
      if (!LogAlarmListenerAdded)
      {
         chrome.alarms.onAlarm.addListener(function(alarm)
         {
            if (alarm.name == 'SendLogFile') _SendLogFile();
         });
         LogAlarmListenerAdded = true;
      }
      
      chrome.alarms.create('SendLogFile', {periodInMinutes: 1});
      TimeoutStarted = true;
   }
   else
      TimeoutStarted = setTimeout(function()
      {
         try
         {
            _SendLogFile();
         }
         catch (e)
         {
            Log_WriteException(e);
         }
      }, 500);
}

function Log_GetLogFile()
{
   let header = '';
   
   if (Browser.IsExtensionBackground())
      header = header + chrome.runtime.getManifest().name + ' Chrome extension v' + chrome.runtime.getManifest().version +
         ' with constants v' + CONSTANTS_VERSION + "\r\n";
   else
      header = header + 'At URL ' + window.location.href + "\r\n";
   
   
   header = header + Browser.GetOS() + ' ' + Browser.GetName() + ' ' + Browser.GetVersion() + ' ' + "\r\n\r\n";
   
   for (const name in MetaLogging)
   {
      header = header + name + ":\r\n" + MetaLogging[name] + "\r\n\r\n";
   }
   
   return header + AccumulatedLogging;
}

var logUploadClientFileID = null;
var logUploadResolve = null;
var logUploadData = null;
var logUploadParameters = null;

function _UploadLogFileChunk(resp, httpCode)
{
   if (httpCode == 200)
   {
      if (resp != -1)   // for the first chunk this will be -1
      {
         logUploadParameters.SequenceNumber++;
         logUploadParameters.SequenceOffset += LogUploadChunkSize;
      }
      
      if (logUploadParameters.SequenceOffset < logUploadData.length)
      {
         const chunkData = logUploadData.substring(logUploadParameters.SequenceOffset, logUploadParameters.SequenceOffset + LogUploadChunkSize);
         
         ajax.post(Form_RootUri + '/v2/TemporaryFiles/' + logUploadClientFileID + '?' + ConvertParamsForSending(logUploadParameters).join('&'),
            chunkData, _UploadLogFileChunk, true, 600000, {
               'Content-Type': 'text/plain;charset=UTF-8'
               // DRL FIXIT? Include Content-Transfer-Encoding?
            });
         return;
      }
      
      Log_WriteInfo('Uploaded log file ' + logUploadParameters.Filename + ' of ' + logUploadParameters.FileSize + ' bytes as ' + logUploadClientFileID);
      logUploadResolve(logUploadClientFileID);
   }
   else if (resp == null || httpCode == 0)
   {
      // server unavailable, network error, etc.
      Log_WriteWarning('Server is not available to upload log file ' + logUploadParameters.Filename + ' of ' + logUploadParameters.FileSize + ' bytes');
      logUploadResolve(null);
   }
   else
   {
      // This will result in an endless stream of trying to upload log files if we make it an error.
      Log_WriteWarning('Error uploading log file ' + logUploadParameters.Filename + ' of ' + logUploadParameters.FileSize + ' bytes: ' + httpCode);
      logUploadResolve(null);
   }
   
   logUploadClientFileID = null;
   logUploadResolve = null;
   logUploadData = null;
   logUploadParameters = null;
}

async function _UploadTemporaryLogFile(filename, mimeType, data)
{
   return new Promise((resolve, reject) =>
   {
      if (logUploadClientFileID)
      {
         // This will result in an endless stream of trying to upload log files if we make it an error.
         Log_WriteWarning('Error uploading log file ' + filename + ' since there is an upload in progress!');
         resolve(null);
         return;
      }
      
      logUploadClientFileID = Utilities_ReplaceInString(File_GetFilename(filename) + ' ' + Utilities_IntRand(1000, 1000000), ' ', '-');
      logUploadResolve = resolve;
      logUploadData = data;
      logUploadParameters = {
         MimeType: mimeType,
         Filename: filename,
         FileSize: logUploadData.length,
         SequenceNumber: 0,
         SequenceOffset: 0,
      };
      
      _UploadLogFileChunk(-1, 200);
   })
      .catch(e =>
      {
         Log_WriteException(e);
//      resolve(null);
      });
}

async function _SendLogFile()
{
   if (Browser.IsExtensionBackground())
      chrome.alarms.clear('SendLogFile');
   TimeoutStarted = null;
   
   if (AccumulatedLogging != '')
   {
      if (Form_RootUri == null)
      {
         Log_WriteInfo("Not sending log file in dev serverless environment");
         return;
      }
      
      let logging = Log_GetLogFile();
      
      _UploadTemporaryLogFile(GroupName + '.log', 'text/plain', logging)
         .then(function(logUploadClientFileID)
         {
            if (logUploadClientFileID == null)
            {
               Log_WriteWarning("Log file was not sent!");
            }
            else
            {
               ajax.post(Form_RootUri + '/v2/Logs', {
                  'GroupName': GroupName,
                  'ClientFileID': logUploadClientFileID
               }, function(response)
               {
               });
            }
         })
         .catch(e =>
         {
            Log_WriteException(e);
         });
      
      AccumulatedLogging = '';
      LogHasError = false;
   }
}

function Log_GetCallStack()
{
   try
   {
      // throw an exception so we can get a stack trace...
      if (typeof Error !== "undefined")
      {
         throw new Error('');
      }
      throw ''; // Fallback
   }
   catch (exception)
   {
      if (typeof exception.stack !== "undefined")
         return exception.stack.replace(/^(Error\n)/, "");	// strip the "Error\n" that comes at the beginning
   }
   
   return 'Call stack unavailable';
}

function Log_WriteInfo(msg)
{
   Log_Write('info', msg);
}

function Log_WriteWarning(msg)
{
   Log_Write('warning', msg);
}

// if a "snooze date" is provided as a DateAndTime object, the $string be logged as a warning until
// that date, giving us time to fix it without continuing to flood the logs with this error
function Log_WriteError(msg, snoozeDate)
{
   if (snoozeDate && DateAndTime_Now().Compare(snoozeDate) < 0)
      Log_Write('snoozed', msg);
   else
      Log_Write('error', msg);
}

function Log_WriteInfoCallStack(msg)
{
   msg += "\n" + Log_GetCallStack();
   Log_Write('info', msg);
}

function Log_WriteWarningCallStack(msg)
{
   msg += "\n" + Log_GetCallStack();
   Log_Write('warning', msg);
}

function Log_WriteErrorCallStack(msg)
{
   msg += "\n" + Log_GetCallStack();
   Log_Write('error', msg);
}

function Log_WriteException(e, msg)
{
   if (msg)
      msg += "\r\n";
   else
      msg = '';
   if (e.message)
      msg += e.message;
   if (e.stack)
      msg += "\r\n" + e.stack;
   Log_WriteError(msg);
}

function Log_WriteDOM(root, maxLen = null)
{
   if (root == null)
      Log_WriteErrorCallStack('Missing root element parameter!');
   else
      Log_WriteInfo(Utilities_ShortenWithEllipsis(root.outerHTML, maxLen));
}

function Log_Die(msg)
{
   msg += "\n" + Log_GetCallStack();
   Log_Write('error', msg);
   alert(msg);
}
